<!DOCTYPE html>
<html>
<head>
<title>Webtech Practicum 1</title>

<meta name="keywords" content="" />
<meta name="description" content="" />
<meta name="viewport"
	content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1 user-scalable=no">
<meta charset="utf-8">

<link
	href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,700'
	rel='stylesheet' type='text/css'>

<link href="css/test.css" rel="stylesheet" type="text/css">
<script type="text/javascript"
	src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>

<script type="text/javascript" src="js/jquery.smint.js"></script>




<script type="text/javascript">
	$(document).ready(function() {
		$('.subMenu').smint({
			'scrollSpeed' : 1000
		});
	});
</script>

</head>
<body onload="setTimeout(function() { window.scrollTo(0, 1) }, 100);">

	<div class="wrap">

		<div class="subMenu">
			<div class="inner">
				<a href="#" id="sTop" class="subNavBtn">Introductie</a> 
				<a href="#" id="s1" class="subNavBtn">Ontstaan</a> 
				<a href="#" id="s2" class="subNavBtn">Header Fields</a> 
				<a href="#" id="s3" class="subNavBtn">Media types</a>
				<a href="#" id="s4" class="subNavBtn">voorbeeld</a> 
				<a href="#" id="s5" class="subNavBtn">Toekomst</a>
				<a href="#" id="s6" class="subNavBtn end">Conclusie & Referencies</a>
			</div>



		</div>


		<div class="section sTop">



			<div class="inner"></div>
			<br class="clear">
		</div>





		<div class="section s1">

			<div class="inner">
				<h2>Introductie</h2>
				<p>MIME betekent Multipurpose Internet Mail Extensions. Dit
					klinkt heel ingewikkeld en niet heel belangrijk, maar MIME is een
					internet standaard die het mogelijk maakt media types the labelen,
					nieuwe media types te registreren en deze te encoden zodat ze over
					het internet via berichten verstuurd konden worden. Het maakte het
					mogelijk om andere karakter sets dan US-ASCII te gebruiken,
					attachments die geen tekst waren eenvoudig mee te sturen, een
					bericht te sturen met meerdere soorten media en header informatie
					in non-ASCII te schrijven. Dit wordt gedaan door gebruik te maken
					van header fields en media types.</p>
			</div>

		</div>

		<div class="section s2">
			<div class="inner">

				<h2>Ontstaan van MIME</h2>
				<p>Mail berichten waarin alleen tekst aanwezig was werd in RFC
					822 al in 1982 gedefinieerd. Het succes van dit standaard was zo
					groot dat dit standaard, geheel of deels, is overgenomen, ver
					buiten de grenzen van het internet en het internet SMTP vervoer (
					toentertijd in RFC821 gedefinieerd en vandaag de dag in RFC5321).
					Door de grote hoeveelheid mensen die deze standaard gebruikte
					werden de beperkingen die het bezat steeds restrictiever voor de
					gebruiker.</p>
				<p>RFC 822 was bedoelt om een formaat van tekst bericht te
					specificeren. Zelf al was het bericht een non-tekst bericht zoals
					video berichten, audio berichten en afbeeldingen, kon de gebruiker
					geen andere tekens gebruiker dan de tekens die US-ASCII tekst
					bevatte. De tekens die US-ASCII bevat zijn de kleine letters a tot
					en met z, grote letters A tot en met Z, de getallen 0 tot en met 9
					en 19 leestekens waaronder %, +, < en “. Aangezien er geen
					mechanisme was beschreven voor mail berichten die audio, video,
					Aziatische tekens of tekens uit meerdere Europese talen was er een
					behoefte aan extra specificaties.</p>
				<p>Één van de meest duidelijk merkbare limitatie’s van mail
					systemen die gebaseerd waren op RFC 821/822 was het feit dat de
					inhoud van het mailbericht werd beperkt dor relatief korte
					lijnen(1000 tekens of minder) van 7bit US-ASCII. Dit betekent dat
					alle berichten die een gebruiker wilde versturen wat geen tekst
					berichten was (video, audio, afbeelding) omgezet moesten worden
					naar 7bit bytes die gerepresenteerd konden worden als US-ASCII
					tekst voordat de gebruiker zijn lokale mail UA ( User Agent, een
					programma waarmee de gebruiker mail kan ontvangen en versturen).</p>
				<p>De beperkingen van RFC 822 werden nog duidelijker doordat
					gateways ingesteld waren om mail berichten tussen RFC 822 en X.400
					hosts toe te laten. X.400 specifieert mechanismen voor het aanwezig
					zijn van non-tekst onderdelen in een mail bericht. De standaarden
					die op dat moment gebruikt werden voor het versturen van berichten
					van X.400 bericht naar een RFC 822 bericht gaven aan dat de
					afbeelding geconverteerd moesten worden naar tekst of dat het
					non-tekst object weggelaten moest worden en tegen de ontvanger
					zeggen dat er informatie was weggelaten. Dit is natuurlijk
					ongewenst als de gebruiker graag het toegevoegde bestand wilde
					ontvangen. Zelfs als de user agent de afbeelding niet kan
					converteren kon de gebruiker misschien met externe programma’s om
					deze taak te volbrengen. MIME bracht hier een verandering in door
					de meeste problemen die het RFC 822 had op te lossen zonder
					serieuze onverenigbaarheden toe te voegen aan de bestaande RFC 822
					mail wereld.</p>
			</div>

		</div>

		<div class="section s3">
			<div class="inner">

				<h2>Header Fields</h2>
				<p>MIME gebruikt een aantal header fields om de content van een
					MIME geheel te beschrijven. Vier header types waren van groot
					belang:</p>
				<ul>
					<li>Een MIME-Version header field, hier wordt weergegeven
						welke versie van MIME gebruikt wordt door het versie nummer te
						checken of te zien dat er geen MIME gebruikt wordt als de mail
						agent ziet dat dit veld ontbreekt.</li>
					<li>Een Content-Type header field, dit veld kan gebruikt
						worden om aan te geven welk media type en subtype de data in de
						body (gedeelte van een bericht waar de data aanwezig is) is
						waardoor de mail agent van de ontvanger duidelijk te zien krijgt
						hoe hij de data moet presenteren.</li>
					<li>Een Content-Transfer-Encoding header field, dit veld wordt
						gebruikt om aan te geven welke codering is aangebracht op de body.
						De codering die op het e-mail bericht wordt aangebracht wordt
						grotendeels gedaan zodat het bericht mail transport mechanismes
						kan passeren die data of teken set limitaties kunnen hebben.</li>
					<li>Twee extra header fields die gebruikt kunnen worden om de
						data in de body nog preciezer te beschrijven, dit zijn namelijk de
						Content-ID en Content-Description header fields. Al de header
						fields die aanwezig zijn voldoen aan de voorwaarden voor header
						fields die in RFC 822 zijn vastgesteld. Ook kunnen alle headers
						fields die besproken worden RFC 822 comments bevatten, deze hebben
						geen semantische waarde en zullen door MIME genegeerd worden.</li>
				</ul>
				<p>Een formele defenitie van deze fields is als volgt:
				<p>
					entity-headers := [ content CRLF ]<BR> [ encoding CRLF]<BR>
					[ id CRLF]<BR> [ description CRLF]<BR>
				</p>
				<p>
					MIME-message-headers := entity-headers<BR> fields<BR>
					version CRLF<BR>
				</p>
				<p>
					MIME-part-headers := entity-headers <BR> [ fields ]<BR>
				</p>
				CRLF = Enter<BR>
				</p>
			</div>

		</div>

		<div class="section s4">
			<div class="inner">
				<h2>MIME-version Header Field</h2>
				<p>
					Alhoewel MIME een extensie is die verenigbaar is met het standaard
					dat beschreven is in RFC 822, zijn er toch omstandigheden waarin
					het wenselijk zou zijn om een post-processing middel te laten weten
					of het bericht samengesteld was met de nieuwe standaard of niet.
					Daarom is de MIME-Version header field aanwezig, die aangeeft in
					welk versie van MIME de body van het bericht is samengesteld.
					Berichten die gebruik maken van MIME moeten dit aangeven door
					bijvoorbeeld de regel: MIME-Version: 1.0 (in dit geval de versie
					1.0 van MIME) te vermelden. Aangezien het mogelijk is dat er in de
					toekomst een nieuwere versie van MIME wordt gebruikt kunnen zowel
					de 1 als de 0 verschillende nummers bevatten om duidelijk te maken
					dat het om een andere versie gaat. De formele definitie van het
					MIME-Version field is:<br> version := “MIME-Version” “:”
					1*DIGIT “.” 1*DIGIT <br> <br> Mocht een bericht verstuurd
					zijn gebruikmakend van MIME moet het MIME-Version header field de
					eerste regel zijn in het bericht. Wanneer dit veld niet aanwezig is
					heeft de mail user agent de mogelijkheid om te bepalen op welke
					manier hij het bericht wilt lezen.
				</p>

			</div>

		</div>

		<div class="section s5">
			<div class="inner">
				<h2>Content-Type Header Field</h2>
				<p>Het doel van de Content-Type field is om de data die het
					bericht in de body ( het gedeelte waar de tekst, afbeeldingen,
					audio of video wordt geplaatst) zo te beschrijven dat het programma
					dat de ontvanger gebruikt om zijn e-mail berichten te bekijken en
					versturen, inziet om wat voor soort bestand het gaat en dit kan
					gebruiken om op de juiste manier het bestand af te handelen. Het
					waarde in dit veld wordt ook wel “media type” genoemd.</p>
				<p>De Content-Type header field bepaald de aard van een entiteit
					door de data in de body een media type en subtype te geven en
					aanvullende informatie te vermelden over de data bij de media types
					en subtypes waarbij dit nodig is. Na de media type en subtype namen
					bestaat de overige ruimte van het header field uit parameters die
					op een attribuut= waarde manier is genoteerd.</p>
				<p>In het algemeen wordt de top-level media type gebruikt om een
					algemene uitspraak te doen over de type data terwijl de subtype een
					specifieke formaat data van de media type aangeeft. Een media type
					is dus bijvoorbeeld image/abc, doordat er voor de slash image staat
					heeft de user agent genoeg informatie om te weten dat het over een
					afbeelding gaat, zelfs wanneer de UA geen kennis heeft over het
					specifieke beeldformaat “abc”. Dit kan bijvoorbeeld gebruikt worden
					om te beslissen om de data van een subtype die niet bekent is te
					laten zien of dit niet te doen, bij een tekst kan de keuze worden
					gemaakt om het toch gewoon te laten zien, maar met een video, audio
					of een afbeelding wil men dat natuurlijk niet. Om deze reden moet
					een geregistreerde subtype van tekst, audio, video of een
					afbeelding geen ingesloten data bevatten die werkelijk van een
					andere subtype is. Als ze van een andere subtype zijn moet dat dus
					ook worden aangegeven. Parameters modificeren de media subtype en
					zijn dus niet van fundamentele invloed op de aard van de inhoud.
					Welke parameters nuttig zijn hangt van het subtype af, de meeste
					parameters zijn geassocieerd met en specifiek subtype. Ook de media
					type zelf is van invloed omdat er bij een bepaalde media type een
					bepaalde hoeveelheid parameters passen. Er is namelijk geen één
					parameter die voor alle media types zinvol is Parameters kunnen
					verplicht zijn voor bepaalde media types en subtypes. Mocht er een
					parameter zijn die niet bekend is bij MIME zal hij genegeerd
					worden. De parameter “charset” is bijvoorbeeld alleen bruikbaar
					voor de subtype “text”, terwijl de “boundary” parameter verplicht
					is voor elke subtype van de “multipart” media type.</p>
				<p>Er bestaan op dit moment 8 top-level, zes van deze types
					waren discrete vormen, wat betekent dat MIME niet veel aandacht aan
					hoeft te geven, de andere twee zijn samengestelde typen en hebben
					extra aandacht aan moet worden besteedt (zie Media Types voor meer
					informatie). Deze set van acht top level media types is bedoelt om
					compleet te zijn. Men verwacht dat het toevoegen van een extra
					media type ook gedaan kan worden door een extra subtype toe te
					voegen, hierdoor kan het toevoegen zo veel mogelijk worden
					uitgesteld.</p>

			</div>

		</div>

		<div class="section s6">
			<div class="inner">
				<h2>Content-Transfer-Encoding Header Field</h2>
				<p>Veel media types die via berichten worden verstuurd worden
					verstuurd in hun “natuurlijke” formaat, wat inhoud dat het in 8bit
					karakters of als binaire gegevens wordt verzonden. Dat formaat
					gegevens kan over bepaalde transfer protocollen niet worden
					verzonden. SMTP (Simple Mail Transfer Protocol) kan bijvoorbeeld
					alleen 7bit US-ASCII berichten versturen met regels die niet langer
					zijn dan 1000 tekens inclusief lijn separatoren(enters). Het is
					hierdoor noodzakelijk om een standaard mechanisme te definiëren om
					de standaard data te coderen als “7bit short line” formaat. Goede
					etikettering voor ongecodeerde data die minder beperkt wordt in de
					transport is wenselijk. Deze codering wordt door het
					Content-Transfer-Encoding header field aangegeven.</p>
				<p>
					De formele definitie voor de codering is als volgt:<br>
					encoding:= “Content-Transfer-Encoding” “:” mechanism<br>
					mechanism:= “7bit” / “8bit” / “binary” / “quoted-printable” /
					“base64” / ietf-token / x-token
				</p>
				<p>Dit veld geeft in één keer twee stukken informatie. Het laat
					de ontvanger weten met welke codering het bericht verandert is en
					er wordt ook aangegeven welke decodering moet worden gebruikt om de
					oorspronkelijke data te krijgen. Het transformeer gedeelte van de
					Content-Transfer-Encodings specificeert expliciet of impliciet
					welke decodering algoritme moet worden gebruikt en om de originele
					data te laten zien of om erachter te komen dat het niet op de
					genoemde manier is gecodeerd. Terwijl er bij het coderen kan worden
					gekozen op welke manier de data wordt verandert, kan er bij het
					decoderen maar 1 goede mogelijkheid is.</p>
				<p>De drie meest gebruikte soorten codering zijn: identity,
					“quoted-printable” codering en de “base64” codering. Met als
					domein: “binairy”, “8bit” of “7bit”. The quoted-printable en base64
					codering transformeren beide de input van een bepaald domein naar
					“7bit”data, waardoor het bericht zonder zorgen overgedragen kan
					worden aan een beperktere e–mail transport. Wanneer er gebruik
					wordt gemaakt van een Content-Tranfer-Encoding label moet altijd
					het correcte label worden gebruikt. Het labelen van data met 8bit
					karakters als “7bit” is niet toegestaan.</p>
				<p>In tegenstelling tot media subtypen, is het toevoegen van
					nieuwe types zowel onwenselijk als onnodig. Echter een enkele
					codering om data om te zetten naar 7bit lijkt niet mogelijk. Er is
					sprake van een afweging tussen compactheid en efficiëntie van de
					codering van grotendeels binaire data en het verlangen om de
					codering enigszins ‘leesbaar’ te maken. Daarom zijn er tenminste 2
					codeer mechanismen nodig: een min of meer leesbare codering
					(quoted-printable) en een compacte codering (base64).</p>
			</div>

		</div>

		<div class="section s7">
			<div class="inner">
				<h2>Content-ID Header Field</h2>
				<p>
					Bij de Constructie van een high-level user agent, kan het wenselijk
					zijn om een body te verwijzen naar een andere body. Daarom kunnen
					bodies gelabeld worden met een “Content-ID” header field, die zo
					gegenereerd wordt dat er nergens anders op de wereld een zelfde
					“Content-ID” bestaat:<br> id: “Content-ID” “:” msg-id
				</p>
			</div>

		</div>

		<div class="section s8">
			<div class="inner">
				<h2>Content-Description Header Field</h2>
				<p>
					De mogelijkheid om beschrijvende informatie te kunnen associëren
					met de body is vaak gewenst. Het kan bijvoorbeeld nuttig zijn om
					bij een afbeelding de informatie “foto van onze nieuwe auto”. Dit
					soort tekst kan in de Content-Description header field geplaatst
					worden en is altijd optioneel.<br> Description :=
					“Content-Description” “:” *text
				</p>
			</div>

		</div>

		<div class="section s9">
			<div class="inner">
				<h2>Media Types</h2>
				<p>Het Content-Type field wordt dus gebruikt om het soort data
					te beschrijven door het bericht te voorzien van zowel een media
					type als een subtype en het verstrekken van extra informatie voor
					media typen waarbij dit vereist is. Nadat dit gespecificeerd is
					wordt de rest van het header field gebruikt voor het plaatsen van
					parameters. Zoals hierboven vermeldt is worden top-level media
					typen gebruikt voor het aangeven van de algemene type data waardoor
					de user agent weet dat als hij een bericht ontvangt met image/abc
					dat de data een afbeelding is zelfs als hij geen kennis heeft over
					het specifieke beeldformaat “abc”.</p>
			</div>

		</div>

		<div class="section s10">
			<div class="inner">
				<h2>Top-Level Media Types</h2>
				<p>De definitie van wat een top-level media type bestaat uit de
					volgende 5 eisen:
				<ul>
					<li>Een naam en een beschrijving van het type, inclusie
						criteria voor de vraag of een bepaalde type in aanmerking zou
						komen om een subtype te kunnen zijn van het type.</li>
					<li>De namen en definities van de parameters, indien
						aanwezig,die worden gedefinieerd voor alle subtypes van het type (
						inclusief of de parameters verplicht zijn of optioneel.</li>
					<li>Hoe een user agent en/of een gateway om moet gaan met een
						subtype van dit type.</li>
					<li>Algemene beschouwing over het versturen van entiteiten
						door gateways van dit top-level type.</li>
					<li>Eventuele restricties op content-tranfer-encodings voor
						entiteiten van dit top-level type.</li>
				</ul>
				In totaal zijn er 8 top-level media types, de volgende 6 media types
				worden ook wel Discrete media types genoemd, de inhoud van deze
				typen wordt door non-MIME mechanismes behandeld:
				<ul>
					<li>Text, tekstuele informatie. Het subtype “plain” in het
						bijzonder geeft platte tekst, die geen opmaakopdracht of
						richtlijnen heeft gekregen over hoe de tekst getoond moer worden.
						Plain tekst is bedoelt om tekst weergegeven te laten worden
						“as-is”(zoals het werkelijk is, geen opmaak). Er is geen speciale
						software nodig om de volledige betekenis van de tekst te kunnen
						krijgen. Andere subtypes worden gebruikt om verrijkte tekst vormen
						van applicatiesoftware die de weergave van de tekst kunnen
						verbeteren, maar dit soort software moet niet noodzakelijk zijn om
						het algemene idee van de tekst te kunnen verkrijgen. Mogelijke
						subtypes van “text” zijn daarom elk tekstverwerker formaat dat
						gelezen kan worden zonder het nodig hebben van software programma
						die het formaat begrijpt.</li>
					<li>Image, afbeeldinggegevens.</li>
					<li>Audio, audio data.</li>
					<li>Video, video data.</li>
					<li>Application, een andere vorm van data, meestal of
						ongeïnterpreteerde binaire gegevens of informatie die door een
						applicatie moet worden verwerkt.</li>
					<li>Model, 3d informatie. De data van een bericht met als
						media type “model” is informatie voor een 3d model.</li>
				</ul>
				</p>
				<p>Dit zijn staan de 2 samengestelde top-level media types:
				<ul>
					<li>Multipart, gegevens bestaande uit meerdere entiteiten van
						onafhankelijke data types.</li>
					<li>Message, een ingekapseld bericht. Media van het type
						“message” is deel van of in zijn geheel een bericht object.</li>
				</ul>
				Wanneer er een onbekende subtype van “text” in de data staat wordt
				de data automatisch behandeld alsof het van de subtype “plain” was,
				zolang de gebruikte set van karakters bij MIME bekent is. Alle data
				met zowel een onbekende subtype als een onbekende set karakters
				wordt geïnterpreteerd als het type “application/octet-stream”(wat
				aangeeft dat MIME ervan uitgaat dat dit een body is met willekeurige
				nummers). Mochten er nieuwe media types of subtypes nodig zijn door
				nieuwe soort media kan dat in MIME eenvoudig geïmplementeerd worden.
				Voordat bijvoorbeeld een subtype wordt toegevoegd is er wel een
				registratie procedure om ervoor te zorgen dat het type ordelijk en
				op een goede manier gespecifieerd is.
				</p>
			</div>

		</div>

		<div class="section s11">
			<div class="inner">
				<h2>Discrete Media Types</h2>
				<p>Het “text” media type is bedoelt voor het versturen van
					materiaal in tekstuele vorm. Een parameter “charset” kan worden
					gebruikt om het tekenset dat in de data gebruikt wordt te
					vermelden. Naast “plain” tekst zijn er vele andere formaten om
					tekst te presenteren genaamd “rich text”. Een interessant kenmerk
					van veel van dit soort teksten is dat ze tot op zekere hoogte
					leesbaar zijn zonder de software die ze zou moeten interpreteren.
					Het media type “image” wordt gebruikt wanneer de data die verstuurd
					moet worden een afbeelding is. Elke subtype van “image” geeft een
					ander soort afbeelding formaat aan. Wanneer er data wordt verzonden
					waar in de Content-Type field als media type “audio” is aangegeven
					gaat het om een body waarin audio data zit. Een media type “video”
					geeft aan dat de data in de body een video is. Zoals genoemd zal
					een “image”media type, een “audio” media type en een “video” media
					type met een onbekende subtype behandeld worden als
					“application/octet-stream”. De “application” media type wordt
					gebruikt voor discrete data die in geen één van de andere
					categorieën passen en in het bijzonder voor gegevens die verwerk
					moeten worden door een soort software. Dit si informatie die pas
					zichtbaar of bruikbaar wordt voor de gebruiker nadat het verwerkt
					is door de applicatie. Voorbeelden van applicaties waarvoor deze
					media type gebruikt voor kan worden is bestandoverdracht,
					spreadsheets, data voor mail gebaseerde agenda systemen. “Model”
					wordt gebruikt voor het versturen van modellen. Modellen zijn
					multidimensionale structuren die uit één of meer objecten bestaan.
					Als er meerdere objecten zijn dan is er één object die de
					opstelling/ instelling / verhouding van de anderen bepaalt. De
					objecten hebben allemaal gekalibreerde coördinaten systemen, maar
					hoeven dezelfde eenheid te gebruiken of dezelfde dimensionaliteit.
				</p>
			</div>

		</div>

		<div class="section s12">
			<div class="inner">
				<h2>Multipart & Message Media Type</h2>
				<p>Bij meervoudige eenheden, waarbij één of meer verschillende
					datasets worden gecombineerd in een enkele body, zal er een
					“multipart” media type in de header geplaatst moeten worden. De
					body moet dan één of meer body parts hebben, die elk gescheiden
					zijn door en lijn en de laatste ook een afsluitende lijn bevat. Na
					de scheidingslijnen heeft elke body part zijn eigen header, een
					lege regel en een body area. Een body is een entiteit en moet
					daarom niet geïnterpreteerd worden als een volledig bericht. Het
					eerste verschil is dat het toegestaan is om een body part zonder
					header fields te beginnen. Wanneer er in een body part geen header
					aanwezig is en dus begint met een wit regel wordt ervan uit gegaan
					dat de informatie die in de body part aanwezig is in content-type
					heeft van “text/plain; charset=US-ASCII”, oftewel standaard tekst.
					Mocht er een header field aanwezig zijn in de body part dan is de
					enige header field die van waarde is een header field die begint
					met “Content-“, alle andere fields kunnen genegeerd worden. Alle
					“multipart” types die op dit moment bestaan of in de toekomstige
					types moeten zich aan deze syntax houden. Dit zorgt ervoor dat alle
					user agents de parts apart kunnen herkennen en kunnen scheiden,
					zelf als het een onbekende subtype is. Ook is het vaak wenselijk
					tijdens het zenden van een e-mail om nog een ingekapseld
					mailbericht mee te sturen. Dit wordt gedaan door het speciale media
					type “message”. In het bijzonder de “rfc822” subtype van “message”
					die gebruikt wordt om die gebruikt wordt om rfc822 berichten te
					kapselen. Sub typen van “message” leggen vaak restricties op aan de
					coderingen die gebruikt mogen worden. De beperking die opgelegd
					wordt hangt af van het sub type en worden daarom in samenhang
					beschreven.</p>
			</div>

		</div>

		<div class="section s13">
			<div class="inner">
				<h2>Voorbeeld</h2>
				<p>
					Hieronder wordt een voorbeeld gegeven van een complex bericht dat
					uit meerdere delen bestaat (multipart). Het voorbeeld bevat vijf
					delen: twee inleidende plain text objecten, één ingebed multipart
					bericht, een text/enriched object en een afsluitende ingekapseld
					text bericht in een non-ASCII karakter set. Het ingebedde multipart
					bericht bevat twee objecten die moeten worden weergegeven in
					parallel, een foto en een audio fragment.<br> <br> <br>
					MIME-Version: 1.0<br> From: Nathaniel Borenstein
					<nsb @nsb.fv.com> <br>
					To: Ned Freed <ned @innosoft.com> <br>
					Date: Fri, 07 Oct 2000 20:00:00 -0700 (PDT)<br>
					Subject: A multipart example<br>
					Content-Type: multipart/mixed;<br>
					Boundary=unique-boundary-1<br>
					<br>
					Als u dit leest, wilt u misschien overwegen over te stappen naar
					een andere mail reader die begrijpt hoe je correct een multipart
					bericht correct moet weergeven(want dit hoor je niet te zien).<br>
					<br>
					--unique-boundary-1<br>
					<br>
					Hier kan tekst staan.<br>
					<br>
					--unique-boundary-1<br>
					Content-type: text/plain; charset= US-ASCII<br>
					<br>
					Dit stuk zou deel uitgemaakt kunnen hebben van het vorige gedeelte
					maar is toegevoegd om de splitsing tussen body parts te laten zien.<br>
					<br>
					--unique-boundary-2<br>
					Content-Type: audio/basic<br>
					Content-Transfer-Encoding: base64<br>
					<br>
					base64-codeerde basis formaat audio gaat hier<br>
					<br>
					--unique-boundary-2<br>
					Content-Type: image/jpeg<br>
					Content-Transfer-Encoding: base64<br>
					<br>
					base64-codeerde afbeelding gaat hier<br>
					<br>
					--unique-boundary-2--<br>
					<br>
					--unique-boundary-1<br>
					Content-type: text/enriched<br>
					<br>
					Dit is <bold> <italic>enriched.</italic></bold> <br>
					<br>
					--unique-boundary-1<br>
					Content-Type: message/rfc822<br>
					<br>
					From: (mailbox in US-ASCII)<br>
					To: (adres in US-ASCII)<br>
					Subject: (subject in US-ASCII)<br>
					Content-Type: Text/plain; charset=iso-8859-1<br>
					Content-Transfer-Encoding: Quoted-printable<br>
					<br>
					Extra tekst in ISO-8859-1 gaat hier <br>
					<br>
					--unique-boundary-1-- 
				</p>
			</div>

		</div>

		<div class="section s14">
			<div class="inner">
				<h2>Toekomst</h2>
			</div>

		</div>

		<div class="section s15">
			<div class="inner">
				<h2>conclusie</h2>
			</div>

		</div>

		<div class="section s16">
			<div class="inner">
				<h2>Referenties</h2>
			</div>

		</div>

		<script type="text/javascript">
			var _gaq = _gaq || [];
			_gaq.push([ '_setAccount', 'UA-9804757-1' ]);
			_gaq.push([ '_trackPageview' ]);

			(function() {
				var ga = document.createElement('script');
				ga.type = 'text/javascript';
				ga.async = true;
				ga.src = ('https:' == document.location.protocol ? 'https://ssl'
						: 'http://www')
						+ '.google-analytics.com/ga.js';
				var s = document.getElementsByTagName('script')[0];
				s.parentNode.insertBefore(ga, s);
			})();
		</script>
</body>
</html>